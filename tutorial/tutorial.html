<h1 id="distributed-interactive-simulation">Distributed Interactive Simulation</h1>
<h2 id="i.-introduction">I. Introduction</h2>
<p>Distributed Interactive Simulation (DIS) is a software standard used to help implement simulations, primarily military simulations. The simulations that use DIS typically have multiple hosts connected by a network, and the DIS protocol helps exchange information about the combat units, such as what types of vehicles are used, how they interact, or how they are used in combat operations. DIS is used in many United States Department of Defense (DoD) applications, and has been for decades.</p>
<p>As a software standard DIS involves the definition of dozens of network messages that are exchanged between hosts. The syntax and semantics of the messages, which are called Protocol Data Units (PDUs) in DIS, are carefully defined. The PDUs can, with a correct implementation, be exchanged between CPUs of multiple designs, running many types of operating systems, and these operatons can be done in multiple software languages.</p>
<p>To achieve its simulation operation objectives the DIS standard includes more than just message format issues. The syntax of messages is defined, but DIS also includes more information. Individual messages also include positions expressed in a particular global coordinate system, for example, and there are many other DIS rules that solve problems, such as detecting the presence of netowrked entities, or performing combat operations. The logical operations necessary to complete these operations becomes tricky and non-obvious. DIS simulation users must learn how to make use of the DIS operations, and this can become difficult unless the implementor knows how to do it. There is a standard for DIS defined by the Institute of Electrical and Electronics Engineers (IEEE) standards organization known as IEEE-1278.1. However in any standard the emphasis is placed on achieving unambigous and accurate definitions rather than helpful descriptions of how to make use of the defined features.</p>
<p>That is part of what this document is intended to achieve: describe and teach the effective implementation of the features that DIS can implement. The DIS standard is useful, widely used, and at the same time those using it can find it difficult to implement real application features due to the complex nature involved. It’s helpful to have clear explanations.</p>
<p>That’s only part of it. DIS is flexible, and can be used in a range of applications. Simply listening to and saving the messages sent on the network from a live exercise can be very useful to analysts. They can later used the saved messages to examine what real vehciles or people actually did and use the collected data to help evaluate the effectiveness of combat tactics. Learning how this works, which can involve essentially no graphical display of the entities in a simuation at all, is a change from what’s called the Networked Virtual Environment&quot; (NVE) since there is no “virtual” graphics aspect for the user to view.</p>
<p>The problem space of DIS is common in many ways to those that appear in the commercial game entertainment world. It is very unusual for commercial entertainment games to use DIS, but the technological implementation problems faced by games are often similar to those faced by DIS. If you’re a commercial game programmer, some of the issues discussed here may help your commercial implementations.</p>
<p>There are other features of DIS that will be assessed as well. From an practical or even academic standpoint the number of questions raised through DIS can be enormous. It’s therefore helpful to have specialists cooperate on this DIS Tutorial project. The tutorial project’s structure is, one hopes, helpful in allowing experts on a topic to supply their answers while not causing issues with other sections of the tutorial.</p>
<h3 id="dis-tutorial-purpose">DIS Tutorial Purpose</h3>
<p>Often the people who need to learn something about DIS are programmers who are thrown head-first into the problem. They’re given some vague instructions, usually summed up as “Hey, we need to implement DIS in our application. Go make it work.” Sometimes the programmers don’t have prior experience with distributed simulations or virutal worlds. They often work on the project for a few weeks before moving on to something else, so they need to learn about the subject quickly. They’re OK with coding, and often with network programming, but using DIS often involves a problem domain that is not clear to newcomers. For example, one would think that it is easy to direct an object in a virtual world to move one meter northwest. This is tricker than it may seem at first glance. What coordinate system is being used, and is that using metric or imperial units? How does one uniquely select an object so that it and it alone moves? Learning about each of these tasks can take a programmer days to unravel if he must rely on only the IEEE standard.</p>
<p>Another audience for this document is military or support personnel responsible for making existing DIS simulations work. They usually have good understanding of the military problem domain and perhaps the basics of networking and software installation. While they are subject matter experts on the military actions in the simulation, they may not be familiar with the nuts and bolts of how the simulation protocol works. An understanding of how things are done in DIS is often a great help in getting a simulation working, or understanding the limitations and features that are difficult or impossible to implement in a simulation.</p>
<p>Those using simulations that instead of DIS use HLA, TENA or WebLVC can also benefit from this manual. The HLA Realtime Platform Reference Federation Object Model (RPR-FOM) uses many of the concepts from DIS, and so can TENA. So understanding DIS also helps HLA RPR-FOM and TENA users. Sometimes HLA RPR-FOM simulations and DIS simulations communicate with each other via a protocol gateway, and the use of the gateway can be helped by users who appreciate the shared concepts.</p>
<p>Studying the standard in isolation can be confusing if the reader has no familiarity with the problems inherent to distributed simulations. The IEEE-1278 standards document does not usually explain the “why” it choose to solve the problems it did, or even that the problems it solves are in fact problems. This document includes an overview of distributed simulations and the inherent issues faced when implementing them. In order to explain the issues, background information on distributed simulations and virtual worlds is presented. If you already know all this, you can safely skip it. But for most programmers and administrators it provides the context for features or data in DIS that may seem mysterious at first.</p>
<p>DIS consists of a few dozen network messages exchanged between simulations. Understanding the syntax of these messages and how to create and receive them is the easy part of DIS. A deeper understanding of what the semantic content of the messages are, and what problems they are trying to solve, is more difficult and more valuable.</p>
<p>If you just want to sling some code and skip all the throat-clearing and theory, you can start reading the “Protocol Data Units: Exchanging State Information” section.</p>
<p>DIS standardizes the format of network messages but has no formal programming API. If a programmer wants to create what is known as an “Entity State Protocol”, a network message that defines the location and orientation of an object in a simulation, the implementation of DIS is free to choose function calls of either</p>
<pre><code>espdu.setLocation(newLocation);</code></pre>
<p>or</p>
<pre><code>espdu.setLoc(newLocation);</code></pre>
<p>Those who implement the DIS standard can use any API they choose. The code in this document primarily uses the open-dis implementation, which is available at https://github.com/open-dis. There are implementations for several languages, including Java, Javascript, C++, C#, Objective-C, and Python. There are other implementations of DIS, both open source and commercial. There are also many home-grown implementations of the standard that were created by simulation implementors. They just wrote their own DIS implementation, or the portions of the DIS standard they needed. This means that the code-writers out there are likely see differences in the source code of two applications that do the same thing. But if they understand DIS, the objective of this document, they should be able to overcome the implementation issues.</p>
<p>There are other features of DIS that will be assessed as well. From an practical or even academic standpoint the number of questions raised through DIS can be enormous. It’s therefore helpful to have specialists cooperate on this DIS Tutorial project. The tutorial project’s structure is, one hopes, helpful in allowing experts on a topic to supply their answers while not causing issues with other sections of the tutorial.</p>
<h3 id="graphics">Graphics</h3>
<p>To take the last topic first, the graphics portion of the shared virtual world is a subject unto itself because of the inherent complex nature of the topic. The art that portrays the shared environment may vary depending on the training objectives. In the commercial world, imagine the graphics of “Call of Duty” or other first person shooter entertainment games. Users who buy the games like good-looking and fast game graphics. In the DoD world, sometimes the training objectives also require high quality and quick graphics operations. For example, some flight simulators that replicate ground attack operations. Some applications also rooted in the DoD can instead use 2D maps to portray a shared environment. The objective of the simulation in this case is to provide users with information about where vehicles and units are, rather than individual vehicle appearance. A map-based graphics simulator may also require position updates once every few seconds rather than several times per second.</p>
<p>The choices about what graphics to include in a DIS application depend entirely on the DoD’s training objectives. An implementor may be able to use Google Maps or Open Street Maps, for example. The map graphics are not realistic 3D displays of vehicles, but may achieve the simulation objectives. Alternatively some applications can use 3D graphics in a manner reminiscent of modern commercial games. There are many ways to draw the 3D images we see on the screen, from OpenGL and Direct3D to higher level scene graphs, such as OpenInventor or X3D. At an even higher level of abstraction objects can be rendered with the aid of a 3D game engine such as Lumberyard or Unity. A DIS application may have rudimentary 3D graphics instead of photorealistic 3D graphics, depending on the training use. Again, the audience being trained may benefit from high quality graphics, or still be well trained by a graphics system that is simple but effective in accomplishing the training objective.</p>
<p>Computer graphics is a large and complex subject, and instruction or examples often depend on the graphics standard chosen to describe the environment. We will discuss some graphics implementations for both for 2D maps and 3D applications. In some understandings, graphics use in simulations can be distinguished as being separate from DIS networking. The reality is that graphics are often used in simulations that use DIS, and from a practical standpoint a DIS tutorial has to at least mention how to use it.</p>
<h3 id="formats-and-semantics">Formats and Semantics</h3>
<p>Before the distributed simulation application can be implemented there needed to be a way to exchange <em>state information</em> between simulators. State information includes data about a participant in the simulation that is transmitted to other simulation hosts. In the case of a tank, the state information includes its position, the direction the vehicle is facing, how fast it is moving, whether it is on fire, and subjects such as which way the turret is pointing. It’s this state information and the format that it is exchanged in that DIS standardizes. Once the state information is exchanged the graphics components we just described above can be used to draw the scene that the users see.</p>
<p>It is in the government’s interest to have simulators interoperate with each other, in particular to prevent vendor lock-in. If the protocol for exchanging state information is owned by a company and that company can prevent simulator competitors from entering the market, or charge more to make their simulators interoperate with those from other companies. To be useful the DIS protocol had to be a <em>standard</em>, and an open one. Simply providing a language implementation that did the job without also specifying what was being exchanged was inadequate. So SISO refined the SIMNET network protocol and developed a formal description of it, then took it to the IEEE, where it was approved as an international standard (IEEE-1278.1). From that point on anyone could buy the IEEE standard document and then write their own implementation of the protocol.</p>
<p>As is inevitable with these things, the standard has to be maintained and updated in light of experience and new technology. From the late 80’s until about 1995 the DARPA SIMNET protocol was used; this predated the adoption of DIS as an IEEE standard. The first major release of a standard DIS was DIS version 5, in 1995. It was updated with version 6, in 1998, when a few new network messages were added. Version 7 was adopted in 2012, and that version maintained an almost complete backwards compatiblity to the DIS version 5 of 1995. At the same time it added a few new PDUs (network messages) related to directed energy weapons and also clarified the semantics of protocol. SISO continues to support and update DIS in working groups, today in parallel with the HLA RPR-FOM.</p>
<h3 id="networking">Networking</h3>
<p>Sending the messages defined by DIS involves using, almost always, the TCP/IP networking system. That’s simply because TCP/IP has become so widespread. Once upon a time there were other software networking standards, such as DECnet, IBM Systems Network Architecture (SNA), Open Systems Interconnection (OSI), or AppleTalk. Those high level network protocols are simply not in use to much of an extent these days. In the case of DIS, can be exceptions to the use of TCP/IP in radio alert applications, but this is somewhat rare.</p>
<p>Using TCP/IP to send DIS messages is useful. It is simple enough to use TCP, UDP, broadcast, and multicast. For the most part in this document the objective is to be as simple as possible when discussing the subject. Network programming is intended to stay at the highest levels possible, excluding, to the extent possible, such topics as the IP or lower levels.</p>
<h3 id="parting-thoughts">Parting Thoughts</h3>
<p>Given the technology of the era, the architects of DIS were visionary. Even decades after it was developed and standardized it still holds up quite well. The research it prompted was trailblazing, and served as the starting point for many military simulations and then entertainment industry game applications. The ideas worked out in DIS are still widely used today.</p>
<h3 id="further-reading">Further Reading</h3>
<p><strong>Simulation Interoperabilty Standards Organization (SISO):</strong> http://sisostds.org/<br> <strong>The IEEE DIS Standard, 1998 (Version 6):</strong> https://standards.ieee.org/findstds/standard/1278.1a-1998.html<br> <strong>DIS Wikipedia:</strong> https://en.wikipedia.org/wiki/Distributed_Interactive_Simulation<br> <strong>DIS Plain and Simple, another document that provides information about DIS:</strong> https://www.sisostds.org/DigitalLibrary.aspx?Command=Core_Download&amp;EntryId=29302<br> <strong>SIMNET wikipedia:</strong> https://en.wikipedia.org/wiki/SIMNET<br> <strong>SIMNET History:</strong> http://www.iitsec.org/about/awardsandrecognition/Documents/2015_FellowPaper_Miller.pdf<br> <strong>Still More SIMNET History:</strong> http://www.dtic.mil/dtic/tr/fulltext/u2/a294786.pdf<br> <strong>A whole website devoted to SIMNET history:</strong> http://simnet-history.org/<br> <strong>Networked Graphics: Building Networked Games and Virtual Environments</strong>, Anthony Steed and Manuel Oliveira. https://www.amazon.com/Networked-Graphics-Building-Virtual-Environments/dp/0123744237</p>
<p><strong>Networked Virtual Environments: Design and Implementation</strong>, Sandeep Singhal and Mike Zyda. Sadly out of print. https://www.amazon.com/Networked-Virtual-Environments-Design-Implementation/dp/0201325578/</p>
<h2 id="dis-history">DIS History</h2>
<p>DIS arose from a Defense Advanced Research Agency (DARPA) project in the 1980’s called SIMNET. At the time TCP/IP and high speed networks were just getting their legs, computers and networks were becoming powerful enough to do the computational operations needed, and 3D graphics was in its infancy.</p>
<p>A screen capture from an early SIMNET application is shown below:</p>
<p><img src="I_Introduction/images/SimnetDisplay.jpg"/></p>
<p>Each participant is in a SIMNET application controlled a tank, and each simulator views the shared virutal battlefield. All the vehicles interacted in the same shared enviroment. If one simulator causes the tank it controls to move, the other partipants see that movement, in real time.</p>
<p>The simulators of the era sometimes had displays that replicated a soldier’s view of the battlefield, but the host running the simulation wasn’t networked with other hosts. Each simulator worked in isolation, and an aircraft simulator couldn’t see a tank controlled by another simulator. The idea of SIMNET–quite advanced for the time–was to create a virtual, shared battlefield in which all participants on multiple computers could see and interact with each other. SIMNET’s major accomplishment–it was arguably one of the first large real-time distirubted virtual world–was to serve as a basis for the research that allowed DIS to happen.</p>
<p>DARPA projects were intended to transition out of the incubator research phase and into useful actual implementations. The SIMNET project worked out many of the state information exchange issues that were needed. Once that was done it needed to be standardized and refined outside of DARPA. The group that would eventually do this was Simulation Interoperability Standards Group (SISO) that took over development of the network protocol portion of the project, which they renamed to DIS. SISO developed DIS in a series of workshops held from 1989 to 1996. Once the protocol was developed they took the relevant documents to the IEEE standards group and achieved DIS standard approval.</p>
<p>In today’s commercial game world games like “Call of Duty” or “World of Tanks” do shared environments between hosts routinely. The companies that own these games make a lot of money selling such applications to the public. At the time of SIMNET the concept of a shared, networked environment was revolutionary.</p>
<h1 id="example-dis-applications">Example DIS Applications</h1>
<p>There are a number of example applications of DIS available. This section simply shows a few so the reader can get an idea of what DIS is capable of helping implement. Some of the applicatons shown are commercial.</p>
<h2 id="metavr-and-vrsg">MetaVR and VRSG</h2>
<p>The company MetaVR has created an application that uses DIS called the Virtual Reality Scene Generator (VRSG). The VRSG application can implement views of terrain, with varying weather, and that includes aircraft.</p>
<p><a href="http://www.metavr.com/products/vrsg/vrsgstandalone.html" title="Title">MetaVR</a> Has a web page devoted to the Virtual Reality Scene Generator application. Another web site for VRSG is at <a href="http://www.metavr.com/products/vrsg/vrsgoverview.html%22Title%22">here</a>, which features vehicles at the Yuma proving grounds and the Strait of Hormuz.</p>
<p>http://www.metavr.com/products/vrsg/vrsgstandalone.html</p>
<p><img src="I_Introduction/images/disApplications/vrsgHelo.jpg" alt="Alt text" /> <img src="I_Introduction/images/disApplications/IranianAircraftModels.jpg" alt="Alt text" /> <img src="I_Introduction/images/disApplications/Hormuz.jpg" alt="Alt text" /></p>
<h2 id="battlespace-simulations-and-modern-air-combat-environment">Battlespace Simulations and Modern Air Combat Environment</h2>
<p>This application is put out by Battlespace Simulations, Inc. Their web site is at <a href="https://www.bssim.com/mace/" title="Title">MASE</a> According to company Battlespace Simulations,</p>
<blockquote>
<p>MACE is a physics-based, many-on-many simulation and threat environment with a large order of battle, ideally suited for both standalone mission rehearsal and distributed mission simulation. MACE provides computer generated forces (CGF), sometimes called semi-autonomous forces (SAF), as well as scenario creation, management and IOS features. Using MACE, you can quickly and easily extend your distributed simulation framework. MACE supports the Distributed Interactive Simulation (DIS) architecture including simulation management, entity state, fire, detonate and emissions PDUs.</p>
</blockquote>
<div class="figure">
<img src="I_Introduction/images/disApplications/Mace.jpg" alt="Alt text" />
<p class="caption">Alt text</p>
</div>
<h2 id="acm">ACM</h2>
<p>The ACM project is a free game that can be used in the debian operating system.</p>
<p>A major web site is at <a href="https://packages.debian.org/sid/games/acm" title="Title">ACM</a></p>
<p>According to the site, this is</p>
<blockquote>
<p>multiplayer aerial combat simulation. Players engage in air to air combat against one another using heat seeking missiles and cannons.</p>
</blockquote>
<blockquote>
<p>Main features include:</p>
</blockquote>
<blockquote>
<ul>
<li>Simulation with 6 degrees of freedom.</li>
<li>Structural limit to the vertical positive/negative load.</li>
<li>Classic instruments, navigation and head-up display (HUD).</li>
<li>Several aircraft models implemented, both civil and military.</li>
<li>Two scenes provided, with many runways and radio stations.</li>
</ul>
</blockquote>
<div class="figure">
<img src="I_Introduction/images/disApplications/debian.png" alt="Alt text" />
<p class="caption">Alt text</p>
</div>
<h2 id="diswebgateway">DISWebGateway</h2>
<p><a href="https://github.com/open-dis/DISWebGateway" title="Title">DISWebGateway</a></p>
<p>DISWebGateway is a small open-dis project. The application reads native DIS traffic on the network, then forwards it to a web server. The DIS traffic can be interpreted by a Javascript implementation of DIS and used in a variety of ways. Users can visit a site on the server and see the effect.</p>
<p>This can be quite interesting. The server allows access to a huge range of capabilities, including remote web-based data The screen capture below shows an entity mapped by the Google Maps utility. OpenStreetMap is also supported.</p>
<div class="figure">
<img src="I_Introduction/images/disApplications/WebBasedApp.tiff" alt="Alt text" />
<p class="caption">Alt text</p>
</div>
<h2 id="simulation-standards">Simulation Standards</h2>
<p>DIS is not the only standard used by contributors to the Department of Defense or other the defense departments of other nations. The other standards include High Level Architecture (HLA), Test and Training Enabling Architecture (TENA), and WebLVC. They all perform many of the same operations as DIS, and in fact copy some of the ideas of DIS.</p>
<p>Each of these protocols is discussed in their own section.</p>
<h3 id="high-level-architecture">High Level Architecture</h3>
<p>DIS was the first standard for distributed simulations. Some time later it was believed that it could be improved upon by using different approaches than those of the 80’s, when DIS was created. This resulted in High Level Architecture (HLA).</p>
<p>There are some important differences between DIS and HLA, but they often share important features as well, particularly when describing combat operations. The HLA architecture can cover a wider range of problems in addition to those addressed by DIS.</p>
<h4 id="off-site-tutorials">Off-Site Tutorials</h4>
<p>There are several interesting tutorials about HLA already present. Rather than attempting to supply yet another, the approach in this section is to simply link to the existing HLA tutorials.</p>
<p>Here’s a list of some online HLA tutorials:</p>
<h5 id="pitch-technologies">Pitch Technologies</h5>
<p><a href="http://www.pitchtechnologies.com/hlatutorial/">Pitch Technologies HLA Tutorial</a></p>
<h5 id="mcgill-university">McGill University</h5>
<p><a href="http://msdl.cs.mcgill.ca/people/hv/teaching/MSBDesign/COMP762B2003/presentations/HLA1.pdf">McGill University, Roger MacFarlane</a></p>
<h5 id="center-for-object-technology">Center for Object Technology</h5>
<p><a href="http://www.cit.dk/COT/reports/reports/Case6/06/cot-6-06.pdf">How to become an HLA guru in a short(er) time</a></p>
<h5 id="georgia-institute-of-technology-computational-science-and-engineering-division-richard-m.-fujimoto">Georgia Institute of Technology, Computational Science and Engineering Division, Richard M. Fujimoto</h5>
<p><a href="http://www.acm-sigsim-mskr.org/Courseware/Fujimoto/Slides/FujimotoSlides-20-HighLevelArchitectureIntro.pdf">The High Level Architecture: Introduction</a></p>
<h4 id="hla-and-dis">HLA and DIS</h4>
<h5 id="rpr-fom">RPR-FOM</h5>
<p>HLA was designed and built to be more general than DIS, but at the same time it was very useful to have HLA configurations that did many of the same things. Readers of the tutorials above know something about Federation Object Modules (FOMs). The FOMs define the objects and attributes in an HLA federation.</p>
<p>SISO realized that it would be useful to define a FOM similar to that of DIS, and that’s exactly what they did. The Real-time Platform Reference Federation Object Model <a href="https://www.sisostds.org/DesktopModules/Bring2mind/DMX/Download.aspx?Command=Core_Download&amp;EntryId=30823&amp;PortalId=0&amp;TabId=105">(RPR-FOM)</a> defines a FOM that copies many DIS concepts. RPR-FOM makes it easier to work with DIS appliations.</p>
<p>Consider the location of a simulation entity. In an application RPR-FOM object we can define an object attribute:</p>
<pre><code>&lt;field&gt;
    &lt;name&gt;WorldLocation&lt;/name&gt;
    &lt;dataType&gt;WorldLocationStruct&lt;/dataType&gt;
    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
 &lt;/field&gt;</code></pre>
<p>The simulated object includes an attribute defining its location in the world. The format of this attribute is identical to that used by DIS. As we will see, the WorldLocationStruct defined in the RPR-FOM is exactly the same as that used in DIS.</p>
<pre><code>&lt;fixedRecordData&gt;
                &lt;name&gt;WorldLocationStruct&lt;/name&gt;
                &lt;encoding&gt;HLAfixedRecord&lt;/encoding&gt;
                &lt;semantics&gt;Location of the origin of the entity&#39;s coordinate system shall be specified by a set of three coordinates: X, Y, and Z. The shape of the earth shall be specified using DMA TR 8350.2, 1987. The origin of the world coordinate system shall be the centroid of the earth, with the X-axis passing through the prime meridian at the equator, the Y-axis passing through 90 degrees east longitude at the equator, and the Z-axis passing through the north pole. These coordinates shall represent meters from the centroid of the earth.&lt;/semantics&gt;
                &lt;field&gt;
                    &lt;name&gt;X&lt;/name&gt;
                    &lt;dataType&gt;WorldLocationOffset&lt;/dataType&gt;
                    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
                &lt;/field&gt;
                &lt;field&gt;
                    &lt;name&gt;Y&lt;/name&gt;
                    &lt;dataType&gt;WorldLocationOffset&lt;/dataType&gt;
                    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
                &lt;/field&gt;
                &lt;field&gt;
                    &lt;name&gt;Z&lt;/name&gt;
                    &lt;dataType&gt;WorldLocationOffset&lt;/dataType&gt;
                    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
                &lt;/field&gt;</code></pre>
<p>The closeness of RPR-FOM to DIS is quite useful for many applicatons.</p>
<h4 id="simulation-size">Simulation Size</h4>
<p>HLA can almost always create simulations that can include more entities than DIS-based applications.</p>
<p>Distributed simulations transmit simulation entity attribute values between hosts. This may include information such as position and orientation, and also describe the entity’s speed and acceleration. As we shall see later in descriptions of DIS’s entity state PDU, DIS will transmit all of these attribute values every few seconds even if they do not change. This increases the network use for every entity in the simulation. A simulated truck parked next to a road will send updates every few seconds for all of the attributes mentioned above, even though they did not change. The increased use of the network, which has a limited capacity, can reduce the number of entities the simulation can support.</p>
<p>In contrast HLA can send updates oof the same attributes to other hosts only when they are changed. A parked truck does not change its position or orientation, and its speed and acceleration remain at zero while parked. HLA can send no updates at all to the other participants in the simulation. This drives down network use by letting HLA applications use less bandwidth. In the end, HLA can suppport more simulated entities because it reduces network use for each simulated entites.</p>
<h5 id="network-message-formats">Network Message Formats</h5>
<p>HLA took some fundamentally different technical approaches when compared to those of DIS. DIS made the choice to standardize the syntax and semantics of a few dozen messages sent on the network. All programming languages that can read and send binary data messages are capable of decoding and sending DIS messages. This includes C, C++, Java, Javascript, Objective-C, Python, and dozens of others. Sometimes simulation application programmers like to use specific languages for various reasons. Python and Javascript have been interesting and powerful programming languages of late.</p>
<p>HLA took a different approach. Rather than define the format of messages, it uses standardized Application Protocol Interface (API) for a limited set of languages. The list of APIs for HLA is at <a href="https://www.sisostds.org/APIs.aspx">SISO</a>. Every API is, by definition, specific to a programming language.</p>
<p>The API defines a set of function calls, and the function calls must be language-specific. The primary APIs for HLA are C++ and Java. (There’s also a rarely used API called “Web Services.” Web services refers to a technology that seems not very usable in distributed simulations due to its high latency rates, though it is still supported by SISO. There are today better performing web technologies which will be discussed.)</p>
<p>The full APIs defined are available at SISO. For example, a function in the API for a Java version of the <a href="https://www.sisostds.org/DesktopModules/Bring2mind/DMX/Download.aspx?Command=Core_Download&amp;EntryId=42469&amp;PortalId=0&amp;TabId=105">HLA API</a> looks like this:</p>
<pre><code>virtual void discoverObjectInstance (
 ObjectHandle theObject, // supplied C1
 ObjectClassHandle theObjectClass, // supplied C1
 const char * theObjectName) // supplied C4
throw (
 CouldNotDiscover,
 ObjectClassNotKnown,
 FederateInternalError) = 0;</code></pre>
<p>There is also a C++ API function that performs the same operation, but the syntax of that function call in C++ API element is of course compliant with the C++ language.</p>
<p>Developers who want to use other languages, such as Python or Javascript, may run into problems if in the end a call must be made to the Java or C++ APIs for those languages to access HLA. In contrast the developer can directly decode the DIS messages in the language he prefers to use.</p>
<p>Another interesting problem is how the HLA API function calls are actually achieved. The API defines the names of function calls and what they do, but do not define how the function works. In the end, messages must be exchanged between hosts, and HLA does not define the message format used to accomplish this. The message format to achieve the result of discoverObjectInstance is determined by the vendor that implements the HLA API.</p>
<p>At the abstract level the function above is a call to search for an object instance. But at the practical level the API is silent about how to accomplish discoverObjectInstance(). The messages exchanged between hosts may contain data in the <a href="https://en.wikipedia.org/wiki/Endianness">big or little endian format</a>, and there may be several messages passed between simulation hosts. Since HLA defines the API, but not the nature of messages necessary to implement the API, in practice every implementation of HLA has different binary messages issued on the network.</p>
<p>The lack of a network standard can make multiple applications working together difficult. Imagine two HLA applications that use exactly the same HLA Federation Object Model (FOM). The simulation’s FOM is a configuration component that defines the simulation’s entities and the entity attributes they have. TankApp uses a vendor of HLA that sells a product called SuperHLA, while the application we want it to workk with, called AircraftApp, uses an HLA implementation product named AwesomeHLA. The two vendors use exactly the same API, but the format of messages they put on the network are different from each other, unknown, and incompatible. SuperHLA cannot receive messages sent by AwesomeHLA, and AwesomeHLA cannot receive messages sent by SuperHLA. Perhaps the programmers for SuperHLA decided to use little endian messages, while AwesomeHLA developers chose to use big endian formats. The HLA implementations have no idea about how they should decode the binary messages of the other HLA implementation.</p>
<p>If the two appliations are to interoperate one option is to use the same HLA implementation, either SuperHLA or AwesomeHLA, in both applications. HLA adopted a strong interoperability standard, and it should be possible to point the application at a different HLA library and run it without error or recompiling. In the case of the TankApp and AircraftApp simulations we should be able to pick one of the HLA implementation libraries, use it in both applications, and start the applications again without recompilation. (In practice there seems to be some reluctance by program managers to do this without a good deal of testing.)</p>
<p>Another option is for each application to share its data in DIS format. In addition to using HLA internally the application may issue a feed to the network about entity movement in DIS format. Perhaps the other application that can then receive the DIS feed and share it into its own HLA implementation. The TankApp uses SuperHLA and also issues DIS traffic; AircraftApp uses software to read the DIS issued by TankApp and feed the information into AwesomeHLA.</p>
<p>The DIS solution becomes more practical as the two applicatons start becoming more differing. For example imagine TankApp has a slightly different FOM than AircraftApp. After that four other applications are added to the interaction pool with the intention of all six applications working with each other. The applications use slightly different FOMs, and three differnet versions of HLA by default. For a situation such as that described above, DIS can be a useful tool. Examples of this include that of Interservice/Industry Training, Simulation and Education Conference <a href="http://exhibits.iitsec.org/2016//custom/Playbook_OBW_NTSAfinal1110.pdf">I/ITSEC</a>, called Operation Blended Warrior.</p>
<h4 id="conclusion">Conclusion</h4>
<p>HLA provides a number of advances over DIS, but also has some language-based restrictions.</p>
<p>There are several guides to HLA that are better than what I could write. You should read them.</p>
<h3 id="test-and-training-enabling-architecture-tena">Test and Training Enabling Architecture (TENA)</h3>
<p>Test and Training Enabling Architecture (TENA) is another simulation standard. It’s a very interesting and powerful technology.</p>
<p>TENA was developed by the US Department of Defense, and was intended to include test and training systems on the range.</p>
<h4 id="tena-web-site">TENA Web Site</h4>
<p>The <a href="https://www.tena-sda.org/">TENA Website</a> is maintained by the United States Office of the Secretary of Defense Test Resource Management Center (TRMC), which runs the TENA program.</p>
<h4 id="tena-license">TENA License</h4>
<p>According to wikipedia,</p>
<p>“The TENA software was developed for use by the United States Government with unlimited rights. The software is provided freely for the purpose of promoting interoperability among United States Department of Defense systems. There are no <a href="https://en.wikipedia.org/wiki/International_Traffic_in_Arms_Regulations">International Traffic in Arms Regulations (ITAR)</a> or export restrictions in using the TENA middleware and related TENA products at an international site, although any restrictions for user provided object models, software, or documents are the responsibility of the author(s) of those products. Use of the TENA software (source code and binary code) by individuals is permitted only upon acceptance of terms and conditions available at the <a href="https://www.tena-sda.org/">TENA web site</a> after login.”</p>
<h4 id="access">Access</h4>
<p>TENA requires an account to download the runtime components, but the TENA organization is open to DoD and DoD vendors. Users who register with TENA can download the runtime software for no charge. Some free implementation software is also available for download. It’s strongly suggested that you register at the TENA-sda site.</p>
<h4 id="tena-tutorial">TENA Tutorial</h4>
<p>One of the things that makes TENA fascinating and powerful is its simularity to Common Object Request Broker Architecture (CORBA). CORBA is, among other things, a form of remote objects. Use of remote objects often greatly increases programmer productivity.</p>
<p>An introduction to <a href="https://www.tena-sda.org/display/TENAintro/Documentation">TENA</a> is available.</p>
<p>An image of the TENA implementation:</p>
<p><a href="images/TENA.tiff">TENA</a></p>
<h4 id="tena-networking">TENA Networking</h4>
<p>In addition to the TENA software the DoD supports network implementations at many training and evaluaton sites. This is called Joint Mission Environment Test Capability JMETC. Documents explaining JMETC are available at the TENA web site.</p>
<h3 id="weblvc">WebLVC</h3>
<p>Web-based technology has become highly compelling in the last few years. Readers can confirm this by noting the degree to which the applications they use themselves today are web-based rather than compiled desktop applications. Vendors often make services available via the web rather than compiled, downloaded applications. Web applications often work across multiple operating systems and hosts with little extra work.</p>
<p>SISO runs a <a href="https://www.sisostds.org/StandardsActivities/DevelopmentGroups/WebLVCPDG.aspx">WebLVC development group</a>.</p>
<p>As the SISO group mentions, the WebLVC effort includes</p>
<blockquote>
<p>• An object-model independent section, which defines the common message headers and object-model-independent administrative messages, and defines a template for the kinds of messages that express object-model-specific data.</p>
</blockquote>
<blockquote>
<p>• A Standard WebLVC Object Model section, which defines specific AttributeUpdate and Interaction messages (expressed in the JSON format), based on the semantics of the DIS protocol and the Real-time Platform Reference (RPR) FOM. The Standard WebLVC Object Model is designed to allow a-priori interoperability between web applications, and federates that are built on these common, existing simulation standards.</p>
</blockquote>
<blockquote>
<p>• A section describing the process and rules for hand-authoring new WebLVC messages based on extended or alternative object models.</p>
</blockquote>
<blockquote>
<p>• A section describing rules for automatically generating WebLVC messages directly from an HLA FOM.</p>
</blockquote>
<p>In the end, WebLVC helps define the network messages normally sent by HLA or DIS in JSON terms. This makes network simulation network messages easy to interpret in Javascript.</p>
<p>WebLVC is interesting, but remember that it also possible to send standard DIS messages to Javascript running inside the web page. The open-dis implementation of Javascript DIS can decode the binary PDU and turn it into a Javascript object. WebLVC in some ways resembles HLA messages, however, and can send out only the attributes of objects that have changed. This means that it can often use less bandwidth in a simulation, despite using text for the message format. JSON is also highly optimized; a lot of attention is paid to it.</p>
<p>See <a href="https://jsperf.com/javascript-dis-native-vs-json/2">jsperf</a> for an interesting comparison in performance between binary messages and JSON. Still, on a laptop running a web browser it is claimed that over 50K messages per second can be decoded. That’s more than can be used in a simulation. Also, note the extend to which different webbrowsers achieve different results.</p>
<h2 id="simulation-terminology">Simulation Terminology</h2>
<p>There are a number of terms floating around in the simulation world, and that’s largely the result of the different purposes to which simulations are put. With DIS, the traditional use was what was called “virtual worlds.” Those used 3D computer graphics to display something that resembled a live video feed as closely as possible. Ideally, a viewer of the display could not tell the difference between the 3D graphics application, which displayed a collection of entities whose position and orientation was updated by DIS, and a live video pointed at a live exercise. Of course the computer graphics feed wasn’t close to solving this problem in the 1990’s, but that was the ultimate goal.</p>
<p>Over time it was realized that DIS could be used to achieve other goals. Everything from purely analytical applications of DIS, which assume that there is no graphical result intended at all, to augmented reality, which has some mix between live video and DIS-related graphics. Furthermore the simulations could include either a single user or a great many networked application elements.</p>
<h3 id="implementation-range">Implementation Range</h3>
<p>The image below shows something about how graphics are used in simulation applications, for what purpose. This primarily is related to whether 3D grahics that try to create real world appearances are generated, by how many simulation hosts.</p>
<div class="figure">
<img src="I_Introduction/images/VirtualGraphicsSpread.jpg" alt="Problem Graphics: I_Introduction/images/VirtualGraphicsSpread.jpg" />
<p class="caption">Problem Graphics: I_Introduction/images/VirtualGraphicsSpread.jpg</p>
</div>
<p>This is primarily an attempt to define the terminology used (at least by some) when related to grahics.</p>
<h4 id="analytical-no-display-single-host">Analytical, No Display, Single Host</h4>
<p>Imagine a single host that creates a description of a combat operation. The simulation is so simple that there is no attempt to use more than one host to create the simulation, and what’s more the user does not care about any graphical display of what is happening in the simulation. The traffic is instead simply saved to a database, where the combat operation is assessed after the fact, textually. There’s no effort present any display to the user. What’s more, because there is only one host generating simulaton traffic it is not particularly necessary to use one of the classic features of DIS, the conversational exchange of messages between hosts.</p>
<p>This can be thought of as the most simple simulaton example possible. The single application generates simulation operatin data, saves each message to a database, and later can play back the simulation contents. There’s no attempt to show the simulation to the users in a realistic graphics display. Instead there is perhaps some classic operations research that later assesses the saved data.</p>
<h4 id="anaylytical-multiple-hosts">Anaylytical, Multiple Hosts</h4>
<p>Very similar to a single analytical simulation generation host, but instead of one, the simulation may use several. DIS is more valuable in this scenario; multiple applications working together was an important feature from the start. As with other analytical operations, there is no attempt to use the traffic of the multiple simulation hosts to show anything graphical to the user. The simulation generally uses data operations to write messages to a database, and later reads the data back textually to analyze the simulation.</p>
<h4 id="command-and-control-graphics">Command and Control Graphics</h4>
<p>This is where it starts to become interestng. The simulation is presenting graphical results to users, but those graphics are not an attempt to create realistic displays. Instead the simulation graphics requirements may be met through displays of object or unit locations. The simulation users are satisfied if they can know the position of objects and units. Instead of a realistic display of a tank, the simulation requirements are satisified if there is a map-based display that shows the position of all the tanks in a unit, or the positions of several units. The objective is not to convince the user he is on the battlefield, but to show what the battlefield is up to.</p>
<p>An very simple display of the concept that uses the web-based Open Street Maps Javascript library is shown below. DIS messages are received from the network, and the web page shows unit locations. There is no attempt to make the unit look realistic, only make its location realistic.</p>
<div class="figure">
<img src="I_Introduction/images/MapDisDisplay.jpg" alt="Problem Graphics: _Introduction/images/MapDisDisplay.jpg" />
<p class="caption">Problem Graphics: _Introduction/images/MapDisDisplay.jpg</p>
</div>
<h4 id="virtual-single-host">Virtual, Single Host</h4>
<p>This is where the application is beginning to create graphics that are, in principle or objective, similar to a live video feed. Back in the early 90’s there was an game called “DOOM”; it had a mode in which a single application showed a 3D graphics display to the user, similar to the scene shown below.</p>
<div class="figure">
<img src="I_Introduction/images/doom-ii.jpg" alt="Problem Graphics: (I_Introduction/images/doom-ii.jpg" />
<p class="caption">Problem Graphics: (I_Introduction/images/doom-ii.jpg</p>
</div>
<p>This shows a chainsaw attack on a monster by the player. (DOOM used it’s own, message format, not DIS.) There need be no other host in the simulation. How realistic is it? For the early 90’s, not that bad! There are definitions of “virtual” in software development that include “not physically existing as such but made by software to appear to do so.” In this case DOOM was creating, for the 90’s, virtual grahical content, generated by a single host. Users were placed in graphics environments that were emotionally realistic for the era.</p>
<h4 id="networked-virtual-environment">Networked Virtual Environment</h4>
<p>This is often the environment in which DIS use crops up. While the game DOOM was often running on a single host, DIS often runs on multiple hosts. The situation can be described by the term “Networked Virtual Environment.” Any simulation may have several processes on several hosts running, some of which use 3D graphics to display a virtual world. One better than that available to DOOM in 1993. Examples of the use of Networked Virtual Environment (NVE) include the book title of Mike Zyda and Sandeep Singhal’s book, “Networked Virtual Environments: Design and Implementation.” The term is widely used in academic papers.</p>
<p>An example of a NVE (not necessarily using DIS) is below. This is an example from VR-Engage from the company <a href="https://www.mak.com/">MaK</a>.</p>
<div class="figure">
<img src="I_Introduction/images/VREngage_mak.jpg" alt="Problem Grahics: I_Introduction/images/VREngage_mak.jpg" />
<p class="caption">Problem Grahics: I_Introduction/images/VREngage_mak.jpg</p>
</div>
<p>Note that the 3D display is a bit more realistic than that of DOOM.</p>
<h4 id="augmented-reality">Augmented Reality</h4>
<p>Augmented Reality newly developing software, at least in the commercial implementation sense. Augmented reality started in research years ago, but is not on the verge of widespread commercial deployment. At this time the augmented reality applications may include offerings from Facebook or Microsoft’s HoloLens. There is also future augmented reality technology rumored to be offered from the companies Magic Leap and Apple, as well as future advances from existing vendors. Phones and other mobile devices are likely to be the platforms addressed.</p>
<p>The aspect of augmented reality that is different from virutal reality or NVEs is that it combines a live video feed with a computer-generated 3D display. A good example of the technology is, oddly enough, the game Pokemon running on an Apple iPhone. Examples are shown below:</p>
<div class="figure">
<img src="I_Introduction/images/pokemanCapture.jpg" alt="Problem Graphics: I_Introduction/images/pokemanCapture.jpg" />
<p class="caption">Problem Graphics: I_Introduction/images/pokemanCapture.jpg</p>
</div>
<p>In the Pokemon game this scene involved capture of the creature through interaction with the 3D model as it was dispalyed on the live video feed. The game proved so popular there were crowds of hundreds in popular “monster” areas. The 3D model is used as a target for capture.</p>
<p>For DoD applications one can easily imagine the 3D model of an enemy combatant that may be addressed somehow by an augmented reality application user. DoD developers are likely to supply some sort of products performing roughly this task.</p>
<h4 id="video">Video</h4>
<p>The simulation gets a live video feed. There is no input into the feed, though the source of the feed may be selected by simulation or live data.</p>
<h3 id="summary">Summary</h3>
<p>The most common application term in the DIS world is “Networked Virual Environment (NVE).” The objective of DIS is very often to have a 3D display presented to the simulation user that is virtually correct; a 3D world that is in principle identical to the real world, a <em>virtually correct</em> world. But at the same time one can’t assume DIS is unique to that. It can easily be used in an analytic simulation, or perhaps, not very long from now as the commercial market matures, a useful tool in an augmented reality simulation.</p>
