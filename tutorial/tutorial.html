<h1 id="distributed-interactive-simulation">Distributed Interactive Simulation</h1>
<h2 id="dis-background">DIS Background</h2>
<p>Distributed Interactive Simulation (DIS) is a software standard used to implement networked simulations. The simulations use multiple hosts that are networked, and DIS helps exchange information about entities modeled in the simulation. It is used in many United States Department of Defense (DoD) applications, and has been for decades.</p>
<p>As a software standard DIS involves the definition of dozens of network messages that are exchanged between hosts. The syntax and semantics of the messages, which are called Protocol Data Units (PDUs) in DIS, are carefully defined. The PDUs can, with a correct implementation, be exchanged between CPUs of multiple designs, running many types of operating systems, and these operatons can be done in multiple software languages.</p>
<p>To achieve its simulation operation objectives the DIS standard includes more than just message format issues. The syntax of messages is defined, but DIS includes far more information. Indvidual messages also include positions expressed in a particular global coordinate system, for example, and there are many other DIS rules that solve problems such as detecting the presence of netowrked entities, or performing combat operations. The logical operations necessary to complete these operations becomes tricky and non-obvious. DIS simulation users must learn how to make use of the DIS operatioins, and this becomes difficult. There is a standard for DIS defined by the Institute of Electrical and Electronics Engineers (IEEE) standards organization known as IEEE-1278.1. However in any standard the emphasis is placed on achieving unambigous and accurate definitions rather than helpful descriptions of how to make use of the defined features.</p>
<p>That is part of what this document is intended to achieve: effective implementation of the features that DIS can implement. The DIS standard is useful, widely used, and at the same time those using it can find it difficult to implement real application features due to the complex nature involved. It’s helpful to have clear explanations.</p>
<p>That’s only part of it. DIS is flexible, and can be used in a range of applications. For example, simply listening to and saving the messages sent on the network from a live exercise can be very useful to analysts. They can later used the saved messages to examine what real vehciles or people actually did and use the collected data to help evaluate the effectiveness of combat tactics. Learning how this works, which can involve essentially no graphical display of the entities in a simuation at all, is a change from what’s called the Networked Virtual Environment&quot; (NVE) since there is no “virtual” aspect for the user to view.</p>
<p>The problem space of DIS is common in many ways to those that appear in the commercial game entertainment world. It is very unusual for commercial entertainment games to use DIS, but the implementation problems faced by games are often similar to those faced by DIS. If you’re a commercial game programmer, some of the issues discussed here may help your commercial implementations.</p>
<p>There are several other features of DIS that will be assessed as well. From an practical or even academic stanpoint the number of questions raised throough DIS can be enormous. It’s therefore helpful to have specialists cooperate on this tutorial DIS project. The tutorial project’s structure is, one hopes, helpful in allowing experts on a topic to supply their answers while not causing issues with other sections of the tutorial.</p>
<h2 id="dis-tutorial-purpose">DIS Tutorial Purpose</h2>
<p>Often the people who need to learn something about DIS are programmers who are thrown head-first into the problem. They’re given some vague instructions, usually summed up as “Hey, we need to implement DIS in our application. Go make it work.” Sometimes the programmers don’t have prior experience with distributed simulations or virutal worlds. They often work on the project for a few weeks before moving on to something else, so they need to learn about the subject quickly. They’re OK with coding, and often with network programming, but using DIS often involves a problem domain that is not clear to newcomers. For example, one would think that it is easy to direct an object in a virtual world to move one meter northwest. This is tricker than it may seem at first glance. What coordinate system is being used, and is that using metric or imperial units? How does one uniquely select an object so that it and it alone moves? Learning about each of these tasks can take a programmer days to unravel if he must rely on only the IEEE standard.</p>
<p>Another audience for this document is military or support personnel responsible for making existing DIS simulations work. They usually have good understanding of the military problem domain and perhaps the basics of networking and software installation. While they are subject matter experts on the military actions in the simulation, they may not be familiar with the nuts and bolts of how the simulation protocol works. An understanding of how things are done in DIS is often a great help in getting a simulation working, or understanding the limitations and features that are difficult or impossible to implement in a simulation.</p>
<p>Those using simulations that instead of DIS use HLA or TENA can also benefit from this manual. The HLA Realtime Platform Reference Federation Object Model (RPR-FOM) uses many of the concepts from DIS, and so can TENA. So understanding DIS also helps HLA RPR-FOM and TENA users. Sometimes HLA RPR-FOM simulations and DIS simulations communicate with each other via a protocol gateway, and the use of the gateway can be helped by users who appreciate the shared concepts.</p>
<p>Studying the standard in isolation can be confusing if the reader has no familiarity with the problems inherent to distributed simulations. The IEEE-1278 standards document does not usually explain the “why” it choose to solve the problems it did, or even that the problems it solves are in fact problems. This document includes an overview of distributed simulations and the inherent issues faced when implementing them. In order to explain the issues, background information on distributed simulations and virtual worlds is presented. If you already know all this, you can safely skip it. But for most programmers and administrators it provides the context for features or data in DIS that may seem mysterious at first.</p>
<p>DIS consists of a few dozen network messages exchanged between simulations. Understanding the syntax of these messages and how to create and receive them is the easy part of using DIS. A deeper understanding of what the semantic content of the messages are, and what problems they are trying to solve, is more difficult and more valuable.</p>
<p>If you just want to sling some code and skip all the throat-clearing and theory, you can start reading the “Protocol Data Units: Exchanging State Information” section.</p>
<p>DIS standardizes the format of network messages but has no formal programming API. If a programmer wants to create what is known as an “Entity State Protocol”, a network message that defines the location and orientation of an object in a simulation, the implementation of DIS is free to choose function calls of either</p>
<pre><code>espdu.setLocation(newLocation);</code></pre>
<p>or</p>
<pre><code>espdu.setLoc(newLocation);</code></pre>
<p>Those who implement the DIS standard can use any API they choose. The code in this document primarily uses the open-dis implementation, which is available at https://github.com/open-dis. There are implementations for several languages, including Java, Javascript, C++, C#, Objective-C, and Python. There are other implementations of DIS, both open source and commercial. There are also many home-grown implementations of the standard that were created by simulation implementors. They just wrote their own DIS implementation, or the portions of the DIS standard they needed. This means that the code-writers out there are likely see differences in the source code of two applications that do the same thing. But if they understand DIS, the objective of this document, they should be able to overcome the implementation issues.</p>
<p>[move graphics to distributed simulation terms section]</p>
<h3 id="graphics">Graphics</h3>
<p>To take the last topic first, the graphics portion of the shared virtual world is a subject unto itself because of the inherent complex nature of the topic. The art that portrays the shared environment may vary depending on the training objectives. In the commercial world, imagine the graphics of “Call of Duty” or other first person shooter entertainment games. Users who buy the games like good-looking and fast operating graphics. In the DoD world, sometimes the training objectives also require high quality and quick graphics operations. For example, some flight simulators that replicate ground attack operations. Some applications also rooted in the DoD can instead use 2D maps to portray a shared environment. The objective of the simulation in this case is to provide users with information about where vehicles and units are, rather than individual vehicle appearance. A map-based graphics simulator may also require position updates once every few seconds rather than several times per second.</p>
<p>The choices about what graphics to include in a DIS application depend entirely on the DoD’s training objectives. An implementor may be able to use Google Maps or Open Street Maps, for example, or implement their own map-based requirements. Alternatively some applications can use 3D graphics in a manner reminiscent of modern commercial FPS games. There are many ways to draw the 3D images we see on the screen, from OpenGL and Direct3D to higher level scene graphs, such as OpenInventor or X3D. At an even higher level of abstraction objects can be rendered with the aid of a 3D game engine such as Lumberyard or Unity. A DIS application may have rudimentary 3D graphics instead of photorealistic 3D graphics, depending on the training use. Again, the audience being trained may benefit from high quality graphics, or still be well trained by a graphics system that is simple but effective in accomplishing the training objective.</p>
<p>Computer graphics is a large and complex subject, and instruction or examples often depend on the graphics standard chosen to describe the environment. We will discuss some graphics implementations for both for 2D maps and 3D applications. In some understandings, graphics use in simulations can be distinguished as being separate from DIS networking. The reality is that graphics are often used in simulations that use DIS, and from a practical standpoint a DIS tutorial has to at least mention how to use it.</p>
<h3 id="formats-and-semantics">Formats and Semantics</h3>
<p>Before the distributed simulation application can be implemented there needed to be a way to exchange <em>state information</em> between simulators. State information includes data about a participant in the simulation that is transmitted to other simulation hosts. In the case of a tank, the state information includes its position, the direction the vehicle is facing, how fast it is moving, whether it is on fire, and subjects such as which way the turret is pointing. It’s this state information and the format that it is exchanged in that DIS standardizes. Once the state information is exchanged the graphics components we just described above can be used to draw the scene that the users see.</p>
<p>It is in the government’s interest to have simulators interoperate with each other, in particular to prevent vendor lock-in. If the protocol for exchanging state information is owned by a company and that company can prevent simulator competitors from entering the market, or charge more to make their simulators interoperate with those from other companies. To be useful the DIS protocol had to be a <em>standard</em>, and an open one. Simply providing a language implementation that did the job without also specifying what was being exchanged was inadequate. So SISO refined the SIMNET network protocol and developed a formal description of it, then took it to the IEEE, where it was approved as an international standard (IEEE-1278.1). From that point on anyone could buy the IEEE standard document and then write their own implementation of the protocol.</p>
<p>As is inevitable with these things, the standard has to be maintained and updated in light of experience and new technology. From the late 80’s until about 1995 the DARPA SIMNET protocol was used; this predated the adoption of DIS as an IEEE standard. The first major release of a standard DIS was DIS version 5, in 1995. It was updated with version 6, in 1998, when a few new network messages were added. Version 7 was adopted in 2012, and that version maintained an almost complete backwards compatiblity to the DIS version 5 of 1995. At the same time it added a few new PDUs (network messages) related to directed energy weapons and also clarified the semantics of protocol. SISO continues to support and update DIS in working groups, today in parallel with the HLA RPR-FOM.</p>
<h3 id="networking">Networking</h3>
<p>Sending the messages defined by DIS involves using, almost always, the TCP/IP networking system. That’s simply because TCP/IP has become so widespread. Once upon a time there were other software networking standards, such as DECnet, IBM Systems Network Architecture (SNA), Open Systems Interconnection (OSI), or AppleTalk. Those high level network protocols are simply not in use to much of an extent these days. In the case of DIS, can be exceptions to the use of TCP/IP in radio alert applications, but this is somewhat rare.</p>
<p>Using TCP/IP to send DIS messages is useful. It is simple enough to use TCP, UDP, broadcast, and multicast. For the most part in this document the objective is to be as simple as possible when discussing the subject. Network programming is intended to stay at the highest levels possible, excluding, to the extent possible, such topics as the IP or lower levels.</p>
<h2 id="simulation-terminology">Simulation Terminology</h2>
<p>There’s a question of what to call applications similar to those described above, and academics love to have arguments about terminology. “Virtual world” or “virtual environment” were the early names for the class of application. A virtual world aims for a replication of a real world combined with a sense of immersion, and that requires high fidelity and responsive graphics. Developers can integrate other human senses into the virtual world application, such as haptics (touch), audio, or even smell to increase the feeling of presence.</p>
<p>Some of the early implementations ran on a single, large computer that had several graphical displays attached to it, while other implementations ran on multiple computers connected by a network. “Networked Virtual Environment (NVE) is a more useful description of the applications that run on multiple hosts compared to those that run on a single host.</p>
<p>First person shooter commercial games use essentially the same technoloy as the NVEs used by the military, and must deal with the same implementation issues that we will discuss later. The primary difference between military simulation NVEs and commercial games is the application’s use, not the technology. Military simulations are intended for training and analysis, while games are written to entertain customers. Even if the technology is fundamentally the same, a game used in military training can result in a bad outcome for the users–for example, by making a user think that he will be invulnerable to rifle fire if he ducks behind a sheetrock wall. That behavior may be fun in a game, but it doesn’t reflect reality and trains the military to do dangerous things.</p>
<p>The size of gaming/entertainment industry dwarfs that of the military simulation industry, and the games they sell are often more visually polished. A single top level game title may cost hundreds of millions to develop and market. The business models of the entertainment industry are different from those of the defense industry. The product life cycle of a game may be only a few years, while a military simulation may be in use for decades. What’s more, an entertainment game developer is usually not interested in a standard network protocol. They consider vendor lock-in a feature, not a bug.</p>
<p>Both commercial games and some military simulation applications used for training may share theoretical names such as “first person shooter.” But they have different goals.</p>
<h2 id="other-uses">Other Uses</h2>
<p>DIS was originally intended for virtual and visually-based environments. But existence of a network protocol for exchanging state information was discovered to be useful in other ways, too. At its root, DIS describes the position of things in the world, and that capability can be used in applications other than NVEs. If we subtract the graphics element of the application we’re left with a data feed that includes a description of the dynamic state of a battlefield. We can use this information for a variety of purposes, many of them analytical.</p>
<p>One possible application is to simply archive all the entity position reports. This lets analysts examine at some later period what happened in a simulation, or even what happened in a live exercise. A live training operation may involve every vehicle sending a DIS update when a vehicle moves. If this information is archived, the analyst can use the data later to evaluate user actions.</p>
<p>Constructive simulations can control entities with Artificial Intelligence (AI), whether it be simple or complex, and those entities can use DIS to publish their positions. Applications can use this to create brigade, division, or even corps-sized simulated units that manuever on the battlefield.</p>
<p>DIS has the potential to work in interoperations with the commercial world as well. Augmented reality is an emerging technology and has received enormous investments from technology companies such as Microsoft, Google, and Facebook. It’s probable that augmented reality applications will receive updates from constructive simulations running on mobile devices. Augmented reality goggles worn by a soldier may receive constructive (imaginary) entity updates in DIS format and display them to the user.</p>
<p>DIS is frequently used as “glue” or act as a “shim” to enable applications that use HLA or TENA to talk to each other. HLA has virtues, but interoperablity between HLA applications is a challenge. It’s often easier to get two HLA applications that are RPR-FOM variants to talk to each other using DIS rather than directly over HLA.</p>
<h2 id="parting-thoughts">Parting Thoughts</h2>
<p>Given the technology of the era, the architects of DIS were visionary. Even decades after it was developed and standardized it still holds up quite well. The research it prompted was trailblazing, and served as the starting point for many military simulations and then entertainment industry game applications. The ideas worked out in DIS are still widely used today.</p>
<h2 id="further-reading">Further Reading</h2>
<p><strong>Simulation Interoperabilty Standards Organization (SISO):</strong> http://sisostds.org/<br> <strong>The IEEE DIS Standard, 1998 (Version 6):</strong> https://standards.ieee.org/findstds/standard/1278.1a-1998.html<br> <strong>DIS Wikipedia:</strong> https://en.wikipedia.org/wiki/Distributed_Interactive_Simulation<br> <strong>DIS Plain and Simple, another document that provides information about DIS:</strong> https://www.sisostds.org/DigitalLibrary.aspx?Command=Core_Download&amp;EntryId=29302<br> <strong>SIMNET wikipedia:</strong> https://en.wikipedia.org/wiki/SIMNET<br> <strong>SIMNET History:</strong> http://www.iitsec.org/about/awardsandrecognition/Documents/2015_FellowPaper_Miller.pdf<br> <strong>Still More SIMNET History:</strong> http://www.dtic.mil/dtic/tr/fulltext/u2/a294786.pdf<br> <strong>A whole website devoted to SIMNET history:</strong> http://simnet-history.org/<br> <strong>Networked Graphics: Building Networked Games and Virtual Environments</strong>, Anthony Steed and Manuel Oliveira. https://www.amazon.com/Networked-Graphics-Building-Virtual-Environments/dp/0123744237</p>
<p><strong>Networked Virtual Environments: Design and Implementation</strong>, Sandeep Singhal and Mike Zyda. Sadly out of print. https://www.amazon.com/Networked-Virtual-Environments-Design-Implementation/dp/0201325578/</p>
<h1 id="dis-history">DIS History</h1>
<p>DIS arose from a Defense Advanced Research Agency (DARPA) project in the 1980’s called SIMNET. At the time TCP/IP and high speed networks were just getting their legs, computers and networks were becoming powerful enough to do the computational operations needed, and 3D graphics was in its infancy.</p>
<p>A screen capture from an early SIMNET application is shown below:</p>
<p><img src="images/SimnetDisplay.jpg"/></p>
<p>Each participant is in a SIMNET application controlled a tank, and each simulator views the shared virutal battlefield. All the vehicles interacted in the same shared enviroment. If one simulator causes the tank it controls to move, the other partipants see that movement, in real time.</p>
<p>The simulators of the era sometimes had displays that replicated a soldier’s view of the battlefield, but the host running the simulation wasn’t networked with other hosts. Each simulator worked in isolation, and an aircraft simulator couldn’t see a tank controlled by another simulator. The idea of SIMNET–quite advanced for the time–was to create a virtual, shared battlefield in which all participants on multiple computers could see and interact with each other. SIMNET’s major accomplishment–it was arguably one of the first large real-time distirubted virtual world–was to serve as a basis for the research that allowed DIS to happen.</p>
<p>DARPA projects were intended to transition out of the incubator research phase and into useful actual implementations. The SIMNET project worked out many of the state information exchange issues that were needed. Once that was done it needed to be standardized and refined outside of DARPA. The group that would eventually do this was Simulation Interoperability Standards Group (SISO) that took over development of the network protocol portion of the project, which they renamed to DIS. SISO developed DIS in a series of workshops held from 1989 to 1996. Once the protocol was developed they took the relevant documents to the IEEE standards group and achieved DIS standard approval.</p>
<p>In today’s commercial game world games like “Call of Duty” or “World of Tanks” do shared environments between hosts routinely. The companies that own these games make a lot of money selling such applications to the public. At the time of SIMNET the concept of a shared, networked environment was revolutionary.</p>
<h1 id="example-dis-applications">Example DIS Applications</h1>
<p>There are a number of example applications of DIS available. This section simply shows a few so the reader can get an idea of what DIS is capable of helping implement. Some of the applicatons shown are commercial.</p>
<h2 id="metavr-and-vrsg">MetaVR and VRSG</h2>
<p>The company MetaVR has created an application that uses DIS called the Virtual Reality Scene Generator (VRSG). The VRSG application can implement views of terrain, with varying weather, and that includes aircraft.</p>
<p><a href="http://www.metavr.com/products/vrsg/vrsgstandalone.html" title="Title">MetaVR</a> Has a web page devoted to the Virtual Reality Scene Generator application. Another web site for VRSG is at <a href="http://www.metavr.com/products/vrsg/vrsgoverview.html%22Title%22">here</a>, which features vehicles at the Yuma proving grounds and the Strait of Hormuz.</p>
<p>http://www.metavr.com/products/vrsg/vrsgstandalone.html</p>
<p><img src="images/disApplications/vrsgHelo.jpg" alt="Alt text" /> <img src="images/disApplications/IranianAircraftModels.jpg" alt="Alt text" /> <img src="images/disApplications/Hormuz.jpg" alt="Alt text" /></p>
<h2 id="battlespace-simulations-and-modern-air-combat-environment">Battlespace Simulations and Modern Air Combat Environment</h2>
<p>This application is put out by Battlespace Simulations, Inc. Their web site is at <a href="https://www.bssim.com/mace/" title="Title">MASE</a> According to company Battlespace Simulations,</p>
<blockquote>
<p>MACE is a physics-based, many-on-many simulation and threat environment with a large order of battle, ideally suited for both standalone mission rehearsal and distributed mission simulation. MACE provides computer generated forces (CGF), sometimes called semi-autonomous forces (SAF), as well as scenario creation, management and IOS features. Using MACE, you can quickly and easily extend your distributed simulation framework. MACE supports the Distributed Interactive Simulation (DIS) architecture including simulation management, entity state, fire, detonate and emissions PDUs.</p>
</blockquote>
<div class="figure">
<img src="images/disApplications/Mace.jpg" alt="Alt text" />
<p class="caption">Alt text</p>
</div>
<h2 id="acm">ACM</h2>
<p>The ACM project is a free game that can be used in the debian operating system.</p>
<p>A major web site is at <a href="https://packages.debian.org/sid/games/acm" title="Title">ACM</a></p>
<p>According to the site, this is</p>
<blockquote>
<p>multiplayer aerial combat simulation. Players engage in air to air combat against one another using heat seeking missiles and cannons.</p>
</blockquote>
<blockquote>
<p>Main features include:</p>
</blockquote>
<blockquote>
<ul>
<li>Simulation with 6 degrees of freedom.</li>
<li>Structural limit to the vertical positive/negative load.</li>
<li>Classic instruments, navigation and head-up display (HUD).</li>
<li>Several aircraft models implemented, both civil and military.</li>
<li>Two scenes provided, with many runways and radio stations.</li>
</ul>
</blockquote>
<div class="figure">
<img src="images/disApplications/debian.png" alt="Alt text" />
<p class="caption">Alt text</p>
</div>
<h2 id="diswebgateway">DISWebGateway</h2>
<p><a href="https://github.com/open-dis/DISWebGateway" title="Title">DISWebGateway</a></p>
<p>DISWebGateway is a small open-dis project. The application reads native DIS traffic on the network, then forwards it to a web server. The DIS traffic can be interpreted by a Javascript implementation of DIS and used in a variety of ways. Users can visit a site on the server and see the effect.</p>
<p>This can be quite interesting. The server allows access to a huge range of capabilities, including remote web-based data The screen capture below shows an entity mapped by the Google Maps utility. OpenStreetMap is also supported.</p>
<div class="figure">
<img src="images/disApplications/WebBasedApp.tiff" alt="Alt text" />
<p class="caption">Alt text</p>
</div>
<h1 id="distributed-interactive-simulation-1">Distributed Interactive Simulation</h1>
<h2 id="simulation-standards">Simulation Standards</h2>
<p>DIS is not the only standard used by contributors to the Department of Defense or other the defense departments of other nations. The other standards include High Level Architecture (HLA), Test and Training Enabling Architecture (TENA), and WebLVC. They all perform many of the same operations as DIS, and in fact copy some of the ideas of DIS.</p>
<p>Each of these protocols is discussed in their own section.</p>
<h1 id="simulation-standards-1">Simulation Standards</h1>
<h2 id="high-level-architecture">High Level Architecture</h2>
<p>DIS was the first standard for distributed simulations. Some time later it was believed that it could be improved upon by using different approaches than those of the 80’s, when DIS was created. This resulted in High Level Architecture (HLA).</p>
<p>There are some important differences between DIS and HLA, but they often share important features as well, particularly when describing combat operations. The HLA architecture can cover a wider range of problems in addition to those addressed by DIS.</p>
<h3 id="off-site-tutorials">Off-Site Tutorials</h3>
<p>There are several interesting tutorials about HLA already present. Rather than attempting to supply yet another, the approach in this section is to simply link to the existing HLA tutorials.</p>
<p>Here’s a list of some online HLA tutorials:</p>
<h4 id="pitch-technologies">Pitch Technologies</h4>
<p><a href="http://www.pitchtechnologies.com/hlatutorial/">Pitch Technologies HLA Tutorial</a></p>
<h4 id="mcgill-university">McGill University</h4>
<p><a href="http://msdl.cs.mcgill.ca/people/hv/teaching/MSBDesign/COMP762B2003/presentations/HLA1.pdf">McGill University, Roger MacFarlane</a></p>
<h4 id="center-for-object-technology">Center for Object Technology</h4>
<p><a href="http://www.cit.dk/COT/reports/reports/Case6/06/cot-6-06.pdf">How to become an HLA guru in a short(er) time</a></p>
<h4 id="georgia-institute-of-technology-computational-science-and-engineering-division-richard-m.-fujimoto">Georgia Institute of Technology, Computational Science and Engineering Division, Richard M. Fujimoto</h4>
<p><a href="http://www.acm-sigsim-mskr.org/Courseware/Fujimoto/Slides/FujimotoSlides-20-HighLevelArchitectureIntro.pdf">The High Level Architecture: Introduction</a></p>
<h3 id="hla-and-dis">HLA and DIS</h3>
<h4 id="rpr-fom">RPR-FOM</h4>
<p>HLA was designed and built to be more general than DIS, but at the same time it was very useful to have HLA configurations that did many of the same things. Readers of the tutorials above know something about Federation Object Modules (FOMs). The FOMs define the objects and attributes in an HLA federation.</p>
<p>SISO realized that it would be useful to define a FOM similar to that of DIS, and that’s exactly what they did. The Real-time Platform Reference Federation Object Model <a href="https://www.sisostds.org/DesktopModules/Bring2mind/DMX/Download.aspx?Command=Core_Download&amp;EntryId=30823&amp;PortalId=0&amp;TabId=105">(RPR-FOM)</a> defines a FOM that copies many DIS concepts. RPR-FOM makes it easier to work with DIS appliations.</p>
<p>Consider the location of a simulation entity. In an application RPR-FOM object we can define an object attribute:</p>
<pre><code>&lt;field&gt;
    &lt;name&gt;WorldLocation&lt;/name&gt;
    &lt;dataType&gt;WorldLocationStruct&lt;/dataType&gt;
    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
 &lt;/field&gt;</code></pre>
<p>The simulated object includes an attribute defining its location in the world. The format of this attribute is identical to that used by DIS. As we will see, the WorldLocationStruct defined in the RPR-FOM is exactly the same as that used in DIS.</p>
<pre><code>&lt;fixedRecordData&gt;
                &lt;name&gt;WorldLocationStruct&lt;/name&gt;
                &lt;encoding&gt;HLAfixedRecord&lt;/encoding&gt;
                &lt;semantics&gt;Location of the origin of the entity&#39;s coordinate system shall be specified by a set of three coordinates: X, Y, and Z. The shape of the earth shall be specified using DMA TR 8350.2, 1987. The origin of the world coordinate system shall be the centroid of the earth, with the X-axis passing through the prime meridian at the equator, the Y-axis passing through 90 degrees east longitude at the equator, and the Z-axis passing through the north pole. These coordinates shall represent meters from the centroid of the earth.&lt;/semantics&gt;
                &lt;field&gt;
                    &lt;name&gt;X&lt;/name&gt;
                    &lt;dataType&gt;WorldLocationOffset&lt;/dataType&gt;
                    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
                &lt;/field&gt;
                &lt;field&gt;
                    &lt;name&gt;Y&lt;/name&gt;
                    &lt;dataType&gt;WorldLocationOffset&lt;/dataType&gt;
                    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
                &lt;/field&gt;
                &lt;field&gt;
                    &lt;name&gt;Z&lt;/name&gt;
                    &lt;dataType&gt;WorldLocationOffset&lt;/dataType&gt;
                    &lt;semantics&gt;-NULL-&lt;/semantics&gt;
                &lt;/field&gt;</code></pre>
<p>The closeness of RPR-FOM to DIS is quite useful for many applicatons.</p>
<h4 id="simulation-size">Simulation Size</h4>
<p>HLA can almost always create simulations that can include more entities than DIS-based applications.</p>
<p>Distributed simulations transmit simulation entity attribute values between hosts. This may include information such as position and orientation, and also describe the entity’s speed and acceleration. As we shall see later in descriptions of DIS’s entity state PDU, DIS will transmit all of these attribute values every few seconds even if they do not change. This increases the network use for every entity in the simulation. A simulated truck parked next to a road will send updates every few seconds for all of the attributes mentioned above, even though they did not change. The increased use of the network, which has a limited capacity, can reduce the number of entities the simulation can support.</p>
<p>In contrast HLA can send updates oof the same attributes to other hosts only when they are changed. A parked truck does not change its position or orientation, and its speed and acceleration remain at zero while parked. HLA can send no updates at all to the other participants in the simulation. This drives down network use by letting HLA applications use less bandwidth. In the end, HLA can suppport more simulated entities because it reduces network use for each simulated entites.</p>
<h4 id="network-message-formats">Network Message Formats</h4>
<p>HLA took some fundamentally different technical approaches when compared to those of DIS. DIS made the choice to standardize the syntax and semantics of a few dozen messages sent on the network. All programming languages that can read and send binary data messages are capable of decoding and sending DIS messages. This includes C, C++, Java, Javascript, Objective-C, Python, and dozens of others. Sometimes simulation application programmers like to use specific languages for various reasons. Python and Javascript have been interesting and powerful programming languages of late.</p>
<p>HLA took a different approach. Rather than define the format of messages, it uses standardized Application Protocol Interface (API) for a limited set of languages. The list of APIs for HLA is at <a href="https://www.sisostds.org/APIs.aspx">SISO</a>. Every API is, by definition, specific to a programming language.</p>
<p>The API defines a set of function calls, and the function calls must be language-specific. The primary APIs for HLA are C++ and Java. (There’s also a rarely used API called “Web Services.” Web services refers to a technology that seems not very usable in distributed simulations due to its high latency rates, though it is still supported by SISO. There are today better performing web technologies which will be discussed.)</p>
<p>The full APIs defined are available at SISO. For example, a function in the API for a Java version of the <a href="https://www.sisostds.org/DesktopModules/Bring2mind/DMX/Download.aspx?Command=Core_Download&amp;EntryId=42469&amp;PortalId=0&amp;TabId=105">HLA API</a> looks like this:</p>
<pre><code>virtual void discoverObjectInstance (
 ObjectHandle theObject, // supplied C1
 ObjectClassHandle theObjectClass, // supplied C1
 const char * theObjectName) // supplied C4
throw (
 CouldNotDiscover,
 ObjectClassNotKnown,
 FederateInternalError) = 0;</code></pre>
<p>There is also a C++ API function that performs the same operation, but the syntax of that function call in C++ API element is of course compliant with the C++ language.</p>
<p>Developers who want to use other languages, such as Python or Javascript, may run into problems if in the end a call must be made to the Java or C++ APIs for those languages to access HLA. In contrast the developer can directly decode the DIS messages in the language he prefers to use.</p>
<p>Another interesting problem is how the HLA API function calls are actually achieved. The API defines the names of function calls and what they do, but do not define how the function works. In the end, messages must be exchanged between hosts, and HLA does not define the message format used to accomplish this. The message format to achieve the result of discoverObjectInstance is determined by the vendor that implements the HLA API.</p>
<p>At the abstract level the function above is a call to search for an object instance. But at the practical level the API is silent about how to accomplish discoverObjectInstance(). The messages exchanged between hosts may contain data in the <a href="https://en.wikipedia.org/wiki/Endianness">big or little endian format</a>, and there may be several messages passed between simulation hosts. Since HLA defines the API, but not the nature of messages necessary to implement the API, in practice every implementation of HLA has different binary messages issued on the network.</p>
<p>The lack of a network standard can make multiple applications working together difficult. Imagine two HLA applications that use exactly the same HLA Federation Object Model (FOM). The simulation’s FOM is a configuration component that defines the simulation’s entities and the entity attributes they have. TankApp uses a vendor of HLA that sells a product called SuperHLA, while the application we want it to workk with, called AircraftApp, uses an HLA implementation product named AwesomeHLA. The two vendors use exactly the same API, but the format of messages they put on the network are different from each other, unknown, and incompatible. SuperHLA cannot receive messages sent by AwesomeHLA, and AwesomeHLA cannot receive messages sent by SuperHLA. Perhaps the programmers for SuperHLA decided to use little endian messages, while AwesomeHLA developers chose to use big endian formats. The HLA implementations have no idea about how they should decode the binary messages of the other HLA implementation.</p>
<p>If the two appliations are to interoperate one option is to use the same HLA implementation, either SuperHLA or AwesomeHLA, in both applications. HLA adopted a strong interoperability standard, and it should be possible to point the application at a different HLA library and run it without error or recompiling. In the case of the TankApp and AircraftApp simulations we should be able to pick one of the HLA implementation libraries, use it in both applications, and start the applications again without recompilation. (In practice there seems to be some reluctance by program managers to do this without a good deal of testing.)</p>
<p>Another option is for each application to share its data in DIS format. In addition to using HLA internally the application may issue a feed to the network about entity movement in DIS format. Perhaps the other application that can then receive the DIS feed and share it into its own HLA implementation. The TankApp uses SuperHLA and also issues DIS traffic; AircraftApp uses software to read the DIS issued by TankApp and feed the information into AwesomeHLA.</p>
<p>The DIS solution becomes more practical as the two applicatons start becoming more differing. For example imagine TankApp has a slightly different FOM than AircraftApp. After that four other applications are added to the interaction pool with the intention of all six applications working with each other. The applications use slightly different FOMs, and three differnet versions of HLA by default. For a situation such as that described above, DIS can be a useful tool. Examples of this include that of Interservice/Industry Training, Simulation and Education Conference <a href="http://exhibits.iitsec.org/2016//custom/Playbook_OBW_NTSAfinal1110.pdf">I/ITSEC</a>, called Operation Blended Warrior.</p>
<h3 id="conclusion">Conclusion</h3>
<p>HLA provides a number of advances over DIS, but also has some language-based restrictions.</p>
<p>There are several guides to HLA that are better than what I could write. You should read them.</p>
<h1 id="simulation-standards-2">Simulation Standards</h1>
<h2 id="test-and-training-enabling-architecture-tena">Test and Training Enabling Architecture (TENA)</h2>
<p>Test and Training Enabling Architecture (TENA) is another simulation standard. It’s a very interesting and powerful technology.</p>
<p>TENA was developed by the US Department of Defense, and was intended to include test and training systems on the range.</p>
<h3 id="tena-web-site">TENA Web Site</h3>
<p>The <a href="https://www.tena-sda.org/">TENA Website</a> is maintained by the United States Office of the Secretary of Defense Test Resource Management Center (TRMC), which runs the TENA program.</p>
<h3 id="tena-license">TENA License</h3>
<p>According to wikipedia,</p>
<p>“The TENA software was developed for use by the United States Government with unlimited rights. The software is provided freely for the purpose of promoting interoperability among United States Department of Defense systems. There are no <a href="https://en.wikipedia.org/wiki/International_Traffic_in_Arms_Regulations">International Traffic in Arms Regulations (ITAR)</a> or export restrictions in using the TENA middleware and related TENA products at an international site, although any restrictions for user provided object models, software, or documents are the responsibility of the author(s) of those products. Use of the TENA software (source code and binary code) by individuals is permitted only upon acceptance of terms and conditions available at the <a href="https://www.tena-sda.org/">TENA web site</a> after login.”</p>
<h3 id="access">Access</h3>
<p>TENA requires an account to download the runtime components, but the TENA organization is open to DoD and DoD vendors. Users who register with TENA can download the runtime software for no charge. Some free implementation software is also available for download. It’s strongly suggested that you register at the TENA-sda site.</p>
<h3 id="tena-tutorial">TENA Tutorial</h3>
<p>One of the things that makes TENA fascinating and powerful is its simularity to Common Object Request Broker Architecture (CORBA). CORBA is, among other things, a form of remote objects. Use of remote objects often greatly increases programmer productivity.</p>
<p>An introduction to <a href="https://www.tena-sda.org/display/TENAintro/Documentation">TENA</a> is available.</p>
<p>An image of the TENA implementation:</p>
<p><a href="images/TENA.tiff">TENA</a></p>
<h3 id="tena-networking">TENA Networking</h3>
<p>In addition to the TENA software the DoD supports network implementations at many training and evaluaton sites. This is called Joint Mission Environment Test Capability JMETC. Documents explaining JMETC are available at the TENA web site.</p>
<h1 id="simulation-standards-3">Simulation Standards</h1>
<h2 id="weblvc">WebLVC</h2>
<p>Web-based technology has become highly compelling in the last few years. Readers can confirm this by noting the degree to which the applications they use themselves today are web-based rather than compiled desktop applications. Vendors often make services available via the web rather than compiled, downloaded applications. Web applications often work across multiple operating systems and hosts with little extra work.</p>
<p>SISO runs a <a href="https://www.sisostds.org/StandardsActivities/DevelopmentGroups/WebLVCPDG.aspx">WebLVC development group</a>.</p>
<p>As the SISO group mentions, the WebLVC effort includes</p>
<blockquote>
<p>• An object-model independent section, which defines the common message headers and object-model-independent administrative messages, and defines a template for the kinds of messages that express object-model-specific data.</p>
</blockquote>
<blockquote>
<p>• A Standard WebLVC Object Model section, which defines specific AttributeUpdate and Interaction messages (expressed in the JSON format), based on the semantics of the DIS protocol and the Real-time Platform Reference (RPR) FOM. The Standard WebLVC Object Model is designed to allow a-priori interoperability between web applications, and federates that are built on these common, existing simulation standards.</p>
</blockquote>
<blockquote>
<p>• A section describing the process and rules for hand-authoring new WebLVC messages based on extended or alternative object models.</p>
</blockquote>
<blockquote>
<p>• A section describing rules for automatically generating WebLVC messages directly from an HLA FOM.</p>
</blockquote>
<p>In the end, WebLVC helps define the network messages normally sent by HLA or DIS in JSON terms. This makes network simulation network messages easy to interpret in Javascript.</p>
<p>WebLVC is interesting, but remember that it also possible to send standard DIS messages to Javascript running inside the web page. The open-dis implementation of Javascript DIS can decode the binary PDU and turn it into a Javascript object. WebLVC in some ways resembles HLA messages, however, and can send out only the attributes of objects that have changed. This means that it can often use less bandwidth in a simulation, despite using text for the message format. JSON is also highly optimized; a lot of attention is paid to it.</p>
<p>See <a href="https://jsperf.com/javascript-dis-native-vs-json/2">jsperf</a> for an interesting comparison in performance between binary messages and JSON. Still, on a laptop running a web browser it is claimed that over 50K messages per second can be decoded. That’s more than can be used in a simulation. Also, note the extend to which different web browsers achieve different results.</p>
